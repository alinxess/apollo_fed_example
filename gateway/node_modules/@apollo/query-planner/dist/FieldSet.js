"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectionSetFromFieldSet = exports.groupByScope = exports.groupByResponseName = exports.matchesField = exports.debugPrintFields = exports.printFields = exports.debugPrintField = void 0;
const graphql_1 = require("graphql");
const graphql_2 = require("./utilities/graphql");
const array_1 = require("./utilities/array");
function debugPrintField(field) {
    const def = field.fieldDef;
    return `(${def.name}: ${def.type})${field.scope.debugPrint()}`;
}
exports.debugPrintField = debugPrintField;
function printFields(fields) {
    if (!fields)
        return '[]';
    return ('[' +
        fields
            .map(field => `"${field.scope.parentType.name}.${field.fieldDef.name}"`)
            .join(', ') +
        ']');
}
exports.printFields = printFields;
function debugPrintFields(fields) {
    if (!fields)
        return '[]';
    return '[' + fields.map(f => debugPrintField(f)).join(', ') + ']';
}
exports.debugPrintFields = debugPrintFields;
function matchesField(field) {
    return (otherField) => {
        return field.fieldDef.name === otherField.fieldDef.name;
    };
}
exports.matchesField = matchesField;
exports.groupByResponseName = (0, array_1.groupBy)(field => (0, graphql_2.getResponseName)(field.fieldNode));
exports.groupByScope = (0, array_1.groupBy)(field => field.scope.identityKey());
function selectionSetFromFieldSet(fields, parentType) {
    return {
        kind: graphql_1.Kind.SELECTION_SET,
        selections: Array.from((0, exports.groupByScope)(fields).values()).flatMap((fieldsByScope) => {
            const scope = fieldsByScope[0].scope;
            return wrapInInlineFragmentIfNeeded(Array.from((0, exports.groupByResponseName)(fieldsByScope).values()).map((fieldsByResponseName) => {
                return combineFields(fieldsByResponseName).fieldNode;
            }), scope, parentType);
        }),
    };
}
exports.selectionSetFromFieldSet = selectionSetFromFieldSet;
function wrapInInlineFragmentIfNeeded(selections, scope, parentType) {
    const shouldWrap = scope.enclosing || !parentType || scope.isStrictlyRefining(parentType);
    const newSelections = shouldWrap ? wrapInInlineFragment(selections, scope.parentType, scope.directives) : selections;
    return scope.enclosing ? wrapInInlineFragmentIfNeeded(newSelections, scope.enclosing, parentType) : newSelections;
}
function wrapInInlineFragment(selections, typeCondition, directives) {
    return [
        {
            kind: graphql_1.Kind.INLINE_FRAGMENT,
            typeCondition: {
                kind: graphql_1.Kind.NAMED_TYPE,
                name: {
                    kind: graphql_1.Kind.NAME,
                    value: typeCondition.name,
                },
            },
            selectionSet: { kind: graphql_1.Kind.SELECTION_SET, selections },
            directives
        },
    ];
}
function combineFields(fields) {
    const { scope, fieldNode, fieldDef } = fields[0];
    const returnType = (0, graphql_1.getNamedType)(fieldDef.type);
    if ((0, graphql_1.isCompositeType)(returnType)) {
        return {
            scope,
            fieldNode: {
                ...fieldNode,
                selectionSet: mergeSelectionSets(fields.map(field => field.fieldNode)),
            },
            fieldDef,
        };
    }
    else {
        return { scope, fieldNode, fieldDef };
    }
}
function mergeSelectionSets(fieldNodes) {
    const selections = [];
    for (const fieldNode of fieldNodes) {
        if (!fieldNode.selectionSet)
            continue;
        selections.push(...fieldNode.selectionSet.selections);
    }
    return {
        kind: 'SelectionSet',
        selections: mergeFieldNodeSelectionSets(selections),
    };
}
function mergeFieldNodeSelectionSets(selectionNodes) {
    const [fieldNodes, fragmentNodes] = (0, array_1.partition)(selectionNodes, (node) => node.kind === graphql_1.Kind.FIELD);
    const mergedFieldNodes = Array.from((0, array_1.groupBy)((node) => { var _a, _b; return (_b = (_a = node.alias) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : node.name.value; })(fieldNodes).values()).map((nodesWithSameResponseName) => {
        const node = { ...nodesWithSameResponseName[0] };
        if (node.selectionSet) {
            node.selectionSet = {
                ...node.selectionSet,
                selections: mergeFieldNodeSelectionSets(nodesWithSameResponseName.flatMap((node) => { var _a; return ((_a = node.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) || []; })),
            };
        }
        return node;
    });
    return [...mergedFieldNodes, ...fragmentNodes];
}
//# sourceMappingURL=FieldSet.js.map