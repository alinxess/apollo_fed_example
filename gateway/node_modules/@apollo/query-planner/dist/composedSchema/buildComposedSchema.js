"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildComposedSchema = exports.supportedFeatures = void 0;
const graphql_1 = require("graphql");
const assert_1 = require("../utilities/assert");
const graphql_2 = require("../utilities/graphql");
const MultiMap_1 = require("../utilities/MultiMap");
const core_1 = require("./core");
const metadata_1 = require("./metadata");
exports.supportedFeatures = [
    'https://specs.apollo.dev/core/v0.1',
    'https://specs.apollo.dev/core/v0.2',
    'https://specs.apollo.dev/join/v0.1',
    'https://specs.apollo.dev/inaccessible/v0.1',
    'https://specs.apollo.dev/tag/v0.1'
].map(core_1.parseFeatureURL);
function buildComposedSchema(document) {
    const schema = (0, graphql_1.buildASTSchema)(document);
    const coreName = 'core';
    const coreDirective = schema.getDirective(coreName);
    (0, assert_1.assert)(coreDirective, `Expected core schema, but can't find @core directive`);
    const joinName = 'join';
    function getJoinDirective(name) {
        const fullyQualifiedName = `${joinName}__${name}`;
        const directive = schema.getDirective(fullyQualifiedName);
        (0, assert_1.assert)(directive, `Composed schema should define @${fullyQualifiedName} directive`);
        return directive;
    }
    const ownerDirective = getJoinDirective('owner');
    const typeDirective = getJoinDirective('type');
    const fieldDirective = getJoinDirective('field');
    const graphDirective = getJoinDirective('graph');
    const graphEnumType = schema.getType(`${joinName}__Graph`);
    (0, assert_1.assert)((0, graphql_1.isEnumType)(graphEnumType), `${joinName}__Graph should be an enum`);
    const graphMap = new Map();
    schema.extensions = {
        ...schema.extensions,
        federation: {
            graphs: graphMap,
        },
    };
    for (const graphValue of graphEnumType.getValues()) {
        const name = graphValue.name;
        const graphDirectiveArgs = (0, graphql_2.getArgumentValuesForDirective)(graphDirective, graphValue.astNode);
        (0, assert_1.assert)(graphDirectiveArgs, `${graphEnumType.name} value ${name} in composed schema should have a @${graphDirective.name} directive`);
        const graphName = graphDirectiveArgs['name'];
        const url = graphDirectiveArgs['url'];
        graphMap.set(name, {
            name: graphName,
            url,
        });
    }
    for (const type of Object.values(schema.getTypeMap())) {
        if ((0, graphql_1.isIntrospectionType)(type))
            continue;
        if (!(0, graphql_1.isObjectType)(type))
            continue;
        (0, assert_1.assert)(type.astNode, `GraphQL type "${type.name}" should contain AST nodes`);
        const ownerDirectiveArgs = (0, graphql_2.getArgumentValuesForDirective)(ownerDirective, type.astNode);
        let typeMetadata;
        if (ownerDirectiveArgs) {
            (0, assert_1.assert)(ownerDirectiveArgs.graph, `@${ownerDirective.name} directive requires a \`graph\` argument`);
            const graph = graphMap.get(ownerDirectiveArgs.graph);
            assertGraphFound(graph, ownerDirectiveArgs.graph, ownerDirective.name);
            typeMetadata = {
                graphName: graph.name,
                keys: new MultiMap_1.MultiMap(),
                isValueType: false,
            };
        }
        else {
            typeMetadata = {
                isValueType: true,
            };
        }
        type.extensions = {
            ...type.extensions,
            federation: typeMetadata,
        };
        const typeDirectivesArgs = (0, graphql_2.getArgumentValuesForRepeatableDirective)(typeDirective, type.astNode);
        (0, assert_1.assert)((0, metadata_1.isEntityTypeMetadata)(typeMetadata) || typeDirectivesArgs.length === 0, `GraphQL type "${type.name}" cannot have a @${typeDirective.name} \
directive without an @${ownerDirective.name} directive`);
        for (const typeDirectiveArgs of typeDirectivesArgs) {
            (0, assert_1.assert)(typeDirectiveArgs.graph, `GraphQL type "${type.name}" must provide a \`graph\` argument to the @${typeDirective.name} directive`);
            const graph = graphMap.get(typeDirectiveArgs.graph);
            assertGraphFound(graph, typeDirectiveArgs.graph, typeDirective.name);
            const keyFields = (0, graphql_2.parseFieldSet)(typeDirectiveArgs['key']);
            typeMetadata.keys.add(graph.name, keyFields);
        }
        for (const fieldDef of Object.values(type.getFields())) {
            (0, assert_1.assert)(fieldDef.astNode, `Field "${type.name}.${fieldDef.name}" should contain AST nodes`);
            const fieldDirectiveArgs = (0, graphql_2.getArgumentValuesForDirective)(fieldDirective, fieldDef.astNode);
            if (!fieldDirectiveArgs)
                continue;
            let fieldMetadata;
            if (fieldDirectiveArgs.graph) {
                const graph = graphMap.get(fieldDirectiveArgs.graph);
                assertGraphFound(graph, fieldDirectiveArgs.graph, fieldDirective.name);
                fieldMetadata = { graphName: graph.name };
            }
            else {
                fieldMetadata = { graphName: undefined };
            }
            fieldDef.extensions = {
                ...fieldDef.extensions,
                federation: fieldMetadata,
            };
            const { requires, provides } = fieldDirectiveArgs;
            if (requires) {
                fieldMetadata.requires = (0, graphql_2.parseFieldSet)(requires);
            }
            if (provides) {
                fieldMetadata.provides = (0, graphql_2.parseFieldSet)(provides);
            }
        }
    }
    return schema;
}
exports.buildComposedSchema = buildComposedSchema;
function assertGraphFound(graph, graphName, directiveName) {
    (0, assert_1.assert)(graph, `Programming error: found unexpected \`graph\` argument value "${graphName}" in @${directiveName} directive`);
}
//# sourceMappingURL=buildComposedSchema.js.map