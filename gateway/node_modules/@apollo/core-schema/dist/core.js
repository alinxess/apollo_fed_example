"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cell = exports.ROLLBACK = exports.Core = exports.ErrCheckFailed = exports.ErrEvalStackEmpty = exports.ErrNoData = void 0;
const error_1 = require("./error");
const ErrNoData = (causes) => error_1.err('NoData', {
    message: 'no data',
    causes
});
exports.ErrNoData = ErrNoData;
const ErrEvalStackEmpty = () => error_1.err('EvalStackEmpty', {
    code: 'EvalStackEmpty',
    message: 'this method must only be called from an evaluator, during evaluation. no evaluation is ongoing.'
});
exports.ErrEvalStackEmpty = ErrEvalStackEmpty;
const ErrCheckFailed = (causes) => error_1.err('CheckFailed', {
    message: 'one or more checks failed',
    causes
});
exports.ErrCheckFailed = ErrCheckFailed;
class Core {
    constructor(data) {
        this._cells = new WeakMap;
        this._stack = [];
        this._traceStack = [];
        this._data = data;
    }
    get data() { return this._data; }
    get(fn) {
        var _a;
        const cell = this.getCell(fn);
        this.evaluate(cell, fn);
        if (!cell.result) {
            throw exports.ErrNoData();
        }
        if (cell.result.data === undefined) {
            if (((_a = cell.result.errors) === null || _a === void 0 ? void 0 : _a.length) === 1)
                throw cell.result.errors[0];
            throw exports.ErrNoData(cell.result.errors);
        }
        return cell.result.data;
    }
    try(fn) {
        var _a;
        const cell = this.getCell(fn);
        this.evaluate(cell, fn);
        return (_a = cell.result) === null || _a === void 0 ? void 0 : _a.data;
    }
    getResult(fn) {
        const cell = this.getCell(fn);
        let result = { errors: [] };
        this.trace(() => {
            var _a;
            this.evaluate(cell, fn);
            result.data = (_a = cell.result) === null || _a === void 0 ? void 0 : _a.data;
        }, (event, _fn, cellResult) => {
            if (event === 'end' && cellResult && cellResult.errors)
                result.errors = result.errors.concat(cellResult.errors);
        });
        return result;
    }
    check(...fns) {
        let errors = [];
        this.trace(() => {
            for (const fn of fns)
                this.try(fn);
        }, (event, _fn, cellResult) => {
            if (event === 'end' && cellResult && cellResult.errors)
                errors = errors.concat(cellResult.errors);
        });
        if (!errors.length)
            return this;
        throw exports.ErrCheckFailed(errors);
    }
    update(update) {
        this._data = update(this.data);
    }
    pure(...passIfChanged) {
        const { currentCell } = this;
        currentCell.pure(...passIfChanged);
    }
    report(...errors) {
        const { currentCell } = this;
        for (const error of errors)
            currentCell.report(error);
    }
    get currentCell() {
        const top = this._stack[this._stack.length - 1];
        if (!top)
            throw exports.ErrEvalStackEmpty();
        return top;
    }
    get currentTracer() {
        return this._traceStack[this._traceStack.length - 1];
    }
    trace(block, onEvent) {
        this._traceStack.push(onEvent);
        try {
            block();
        }
        finally {
            this._traceStack.pop();
        }
    }
    evaluate(cell, fn) {
        const tracer = this.currentTracer;
        this._stack.push(cell);
        try {
            try {
                if (tracer)
                    tracer('begin', fn, cell.result);
                cell.evaluate(this, fn);
            }
            finally {
                if (tracer)
                    tracer('end', fn, cell.result);
            }
        }
        finally {
            this._stack.pop();
        }
    }
    getCell(fn) {
        const existing = this._cells.get(fn);
        if (existing)
            return existing;
        const created = new Cell;
        this._cells.set(fn, created);
        return created;
    }
}
exports.Core = Core;
exports.default = Core;
exports.ROLLBACK = Object.freeze({ ROLLBACK: true });
class Cell {
    constructor() {
        this.status = 'empty';
        this.result = undefined;
        this._pendingResult = undefined;
        this._guards = [];
        this._nextGuard = 0;
    }
    pure(...changed) {
        const index = this._nextGuard++;
        const existing = this._guards[index];
        try {
            if (!existing)
                return;
            if (existing.length !== changed.length)
                return;
            let i = existing.length;
            while (i-- > 0) {
                if (existing[i] !== changed[i])
                    return;
            }
            throw exports.ROLLBACK;
        }
        finally {
            this._guards[index] = changed;
        }
    }
    report(error) {
        var _a;
        const pending = this._pendingResult;
        if (!pending)
            throw new Error('cell is not being evaluated');
        pending.errors = (_a = pending.errors) !== null && _a !== void 0 ? _a : [];
        pending.errors.push(error);
    }
    evaluate(core, fn) {
        const pending = {};
        this._pendingResult = pending;
        const lastStatus = this.status;
        this.status = 'run';
        this._nextGuard = 0;
        let rollback = false;
        try {
            pending.data = fn.call(core, core);
        }
        catch (err) {
            if (err === exports.ROLLBACK) {
                rollback = true;
            }
            else {
                this.report(err);
            }
        }
        finally {
            this._nextGuard = 0;
            if (!rollback) {
                this.result = pending;
                this.status = 'ready';
            }
            else {
                this.status = lastStatus;
            }
            this._pendingResult = undefined;
        }
    }
}
exports.Cell = Cell;
//# sourceMappingURL=core.js.map