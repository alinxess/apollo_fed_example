"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Features = exports.Feature = void 0;
const error_1 = require("./error");
const feature_url_1 = __importDefault(require("./feature-url"));
const names_1 = require("./names");
const ErrTooManyFeatureVersions = (features) => error_1.err('TooManyFeatureVersions', {
    message: `too many versions of ${features[0].url.identity} at v${features[0].url.version.series}`,
    features,
    major: features[0].url.version.major,
    nodes: features.map(f => f.directive),
});
class Feature {
    constructor(url, name, directive, purpose) {
        this.url = url;
        this.name = name;
        this.directive = directive;
        this.purpose = purpose;
    }
    canonicalName(docName) {
        const [prefix, base] = names_1.getPrefix(docName);
        if (prefix) {
            if (prefix !== this.name)
                return null;
            return `${this.url.name}__${base}`;
        }
        if (base !== this.name)
            return null;
        return this.url.name;
    }
}
exports.Feature = Feature;
class Features {
    constructor() {
        this.features = new Map;
    }
    add(feature) {
        const majors = this.findOrCreateIdentity(feature.url.identity);
        const { series } = feature.url.version;
        const existing = majors.get(series);
        if (existing != null) {
            existing.push(feature);
            return;
        }
        majors.set(series, [feature]);
    }
    find(feature, exact = false) {
        var _a, _b;
        feature = typeof feature === 'string' ? feature_url_1.default.parse(feature) : feature;
        const documentFeature = (_b = (_a = this.features.get(feature.identity)) === null || _a === void 0 ? void 0 : _a.get(feature.version.series)) === null || _b === void 0 ? void 0 : _b[0];
        if ((exact && (documentFeature === null || documentFeature === void 0 ? void 0 : documentFeature.url.equals(feature))) ||
            (!exact && (documentFeature === null || documentFeature === void 0 ? void 0 : documentFeature.url.satisfies(feature))))
            return documentFeature;
        return null;
    }
    documentName(feature, exact = false) {
        var _a;
        feature = typeof feature === 'string' ? feature_url_1.default.parse(feature) : feature;
        const found = this.find(feature, exact);
        if (!found)
            return null;
        const element = feature.isDirective ? (_a = feature.element) === null || _a === void 0 ? void 0 : _a.slice(1) : feature.element;
        if (!element || feature.isDirective && (element === found.url.name))
            return found.name;
        return found.name + '__' + element;
    }
    *[Symbol.iterator]() {
        for (const majors of this.features.values()) {
            for (const features of majors.values()) {
                yield* features;
            }
        }
    }
    validate() {
        const errors = [];
        for (const [_, majors] of this.features) {
            for (const [_, features] of majors) {
                if (features.length <= 1)
                    continue;
                errors.push(ErrTooManyFeatureVersions(features));
            }
        }
        return errors;
    }
    findOrCreateIdentity(identity) {
        const existing = this.features.get(identity);
        if (existing)
            return existing;
        const created = new Map();
        this.features.set(identity, created);
        return created;
    }
}
exports.Features = Features;
exports.default = Features;
//# sourceMappingURL=features.js.map