"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ErrNoVersion = exports.ErrNoName = exports.ErrNoPath = void 0;
const url_1 = require("url");
const version_1 = require("./version");
const error_1 = require("./error");
const ErrNoPath = (url, node) => error_1.err('NoPath', {
    message: `feature url does not have a path: ${url}`,
    url,
    nodes: node ? [node] : undefined
});
exports.ErrNoPath = ErrNoPath;
const ErrNoName = (url, node) => error_1.err('NoName', {
    message: `feature url does not specify a name: ${url}`,
    url,
    nodes: node ? [node] : undefined
});
exports.ErrNoName = ErrNoName;
const ErrNoVersion = (url, node) => error_1.err('NoVersion', {
    message: `feature url does not specify a version: ${url}`,
    url,
    nodes: node ? [node] : undefined
});
exports.ErrNoVersion = ErrNoVersion;
class FeatureUrl {
    constructor(identity, name, version, element) {
        this.identity = identity;
        this.name = name;
        this.version = version;
        this.element = element;
    }
    static parse(input, node) {
        const url = new url_1.URL(input);
        if (!url.pathname || url.pathname === '/')
            throw exports.ErrNoPath(url, node);
        const path = url.pathname.split('/');
        const verStr = path.pop();
        if (!verStr)
            throw exports.ErrNoVersion(url, node);
        const version = version_1.Version.parse(verStr);
        const name = path[path.length - 1];
        if (!name)
            throw exports.ErrNoName(url, node);
        const element = url.hash ? url.hash.slice(1) : undefined;
        url.hash = '';
        url.search = '';
        url.password = '';
        url.username = '';
        url.pathname = path.join('/');
        return new FeatureUrl(url.toString(), name, version, element);
    }
    static decode(node) {
        return this.parse(node.value, node);
    }
    satisfies(requested) {
        return requested.identity === this.identity &&
            this.version.satisfies(requested.version);
    }
    equals(other) {
        return this.identity === other.identity &&
            this.version.equals(other.version);
    }
    get url() {
        return this.element ?
            `${this.identity}/${this.version}#${this.element}`
            : `${this.identity}/${this.version}`;
    }
    get isDirective() {
        var _a;
        return (_a = this.element) === null || _a === void 0 ? void 0 : _a.startsWith('@');
    }
    get elementName() {
        var _a;
        return this.isDirective ? (_a = this.element) === null || _a === void 0 ? void 0 : _a.slice(1) : this.element;
    }
    get base() {
        if (!this.element)
            return this;
        return new FeatureUrl(this.identity, this.name, this.version);
    }
    toString() {
        return this.url;
    }
}
exports.default = FeatureUrl;
//# sourceMappingURL=feature-url.js.map